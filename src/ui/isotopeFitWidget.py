# -*- coding: utf-8 -*-
import collections
# Form implementation generated from reading ui file 'FilterFitFrame.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
from matplotlib.figure import Figure
from matplotlib.patches import Rectangle
import matplotlib
import re
import pickle
from PyQt6.QtWidgets import (QGridLayout, QLabel, QSpinBox, QDoubleSpinBox, QWidget, QComboBox, QPushButton, QSizePolicy,
                             QApplication, QMainWindow, QHBoxLayout, QFileDialog, QCheckBox)

from PyQt6.QtCore import QRect, Qt, QCoreApplication, pyqtSignal

# Project imports
from src.ui import isotopeFitTable
from src.records.Session import *


class FilterFitWidget(QWidget):
    regressionComplete = pyqtSignal()
    regressionPickled = pyqtSignal(str)
    def __init__(self, session: Session):
        super().__init__()
        self.session = session
        print("filter init", self.session, self.session.isotopes)
        self.uiState = 'initial'

    def setupUi(self):
        self.setGeometry(QRect(0, 0, 1200, 800))
        self.setContentsMargins(0, 0, 0, 0)

        mainGrid = QGridLayout()
        mainGrid.setGeometry(QRect(0, 0, 1190, 790))
        mainGrid.setContentsMargins(5, 5, 5, 5)

        upperLeftGrid = QGridLayout()
        upperLeftGrid.setGeometry(QRect(0, 0, 275, 515))
        upperLeftGrid.setObjectName('upperLeft')
        upperLeftGrid.setContentsMargins(0, 0, 0, 0)
        
        # ROW 1 Instruction
        row = 0
        self.Instruct1_AssignPars = QLabel()
        self.Instruct1_AssignPars.setObjectName("Instruct1_AssignPars")
        self.Instruct1_AssignPars.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperLeftGrid.addWidget(self.Instruct1_AssignPars, row, 0, 1, 2)
        
        ## BEGIN FILTER GRID
        # ROW 2 Filter parameter grid

        # Line 1:  Max P
        row+=1
        self.maxPLabel = QLabel()
        self.maxPLabel.setObjectName("maxPLabel")
        upperLeftGrid.addWidget(self.maxPLabel, row, 0, 1, 1)
        self.maxPSpinBox = QDoubleSpinBox()
        self.maxPSpinBox.setRange(1E+3, 5E+6)
        self.maxPSpinBox.setDecimals(0)
        self.maxPSpinBox.setSingleStep(1E+3)
        self.maxPSpinBox.setValue(5E+6)
        self.maxPSpinBox.setObjectName("maxPSpinBox")
        upperLeftGrid.addWidget(self.maxPSpinBox, row, 1, 1, 1)
        
        # Line 2: Min P
        row+=1
        self.minPLabel = QLabel()
        self.minPLabel.setObjectName("minPLabel")
        upperLeftGrid.addWidget(self.minPLabel, row, 0, 1, 1)
        self.minPSpinBox = QDoubleSpinBox()
        self.minPSpinBox.setObjectName("minPSpinBox")
        self.minPSpinBox.setRange(0, 1E+5)
        self.minPSpinBox.setDecimals(0)
        self.minPSpinBox.setSingleStep(1E+3)
        self.minPSpinBox.setValue(0)
        upperLeftGrid.addWidget(self.minPSpinBox, row, 1, 1, 1)
        
        # Line 3 Min A
        row += 1
        self.minALabel = QLabel()
        self.minALabel.setObjectName("minALabel")
        upperLeftGrid.addWidget(self.minALabel, 3, 0, 1, 1)
        self.minASpinBox = QDoubleSpinBox()
        self.minASpinBox.setRange(0, 1E+5)
        self.minASpinBox.setDecimals(0)
        self.minASpinBox.setSingleStep(1E+2)
        self.minASpinBox.setValue(2000)
        self.minASpinBox.setObjectName("minASpinBox")
        upperLeftGrid.addWidget(self.minASpinBox, row, 1, 1, 1)
        
        # Line 4: Outlier
        row += 1
        self.outlierLabel = QLabel()
        self.outlierLabel.setObjectName("outlierLabel")
        upperLeftGrid.addWidget(self.outlierLabel, row, 0, 1, 1)
        self.outlierComboBox = QComboBox()
        self.outlierComboBox.setObjectName("outlierComboBox")
        self.outlierComboBox.addItem("")
        self.outlierComboBox.addItem("")
        self.outlierComboBox.addItem("")
        self.outlierComboBox.setCurrentIndex(0)
        upperLeftGrid.addWidget(self.outlierComboBox, row, 1, 1, 1)
        ## END FILTER GRID
        
        # ROW 3: Instruction
        row += 1
        self.Instruct2_Extract = QLabel()
        self.Instruct2_Extract.setObjectName("Instruct2_Extract")
        self.Instruct2_Extract.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperLeftGrid.addWidget(self.Instruct2_Extract, row, 0, 1, 2)
        
        # ROW 3: Start Filter Button
        row += 1
        self.filterRawBtn = FilterButton()
        upperLeftGrid.addWidget(self.filterRawBtn, row, 0, 1, 2)

        
        # ROW 4: Instruction
        row += 1
        self.Instruct3_FitFiltered = QLabel()
        self.Instruct3_FitFiltered.setObjectName("Instruct3_FitFiltered")
        self.Instruct3_FitFiltered.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperLeftGrid.addWidget(self.Instruct3_FitFiltered, 7, 0, 1, 2)
        
        # ROW 5: Fitting Alogrithm Selector
        row += 1
        self.fitComboLabel = QLabel()
        self.fitComboLabel.setText('LS Algorithm:')
        self.fitComboLabel.setContentsMargins(0, 0, 0, 0)
        upperLeftGrid.addWidget(self.fitComboLabel, row, 0, 1, 1)
        self.isotopeFitComboBox = QComboBox()
        self.isotopeFitComboBox.setObjectName("isotopeFitComboBox")
        self.isotopeFitComboBox.addItem("")
        self.isotopeFitComboBox.addItem("")
        self.isotopeFitComboBox.addItem("")
        self.isotopeFitComboBox.setCurrentIndex(1)
        upperLeftGrid.addWidget(self.isotopeFitComboBox, row, 1, 1, 1)

        #Todo: Test Robust least squared. Disabled here
        self.isotopeFitComboBox.model().item(2).setEnabled(False)

        row += 1
        self.normComboLabel = QLabel()
        self.normComboLabel.setText('RLS Norm:')
        self.normComboLabel.setContentsMargins(0, 0, 0, 0)
        upperLeftGrid.addWidget(self.normComboLabel, row, 0, 1, 1)
        self.normComboLabel.setEnabled(False)

        self.normRLSComboBox = QComboBox()
        self.normRLSComboBox.setObjectName("normComboBox")
        self.normRLSComboBox.addItems(["" for i in range(9)])
        upperLeftGrid.addWidget(self.normRLSComboBox, row, 1, 1, 1)
        self.normRLSComboBox.setEnabled(False)


        # Row 6: Start Isotope Fitting
        row += 1
        self.startFitBtn = FitButton()
        upperLeftGrid.addWidget(self.startFitBtn, row, 0, 1, 2)


        # ROW 7: Instruction
        row += 1
        self.Instruct4_ViewFitPlots = QLabel()
        self.Instruct4_ViewFitPlots.setObjectName("Instruct4_ViewFitPlots")
        self.Instruct4_ViewFitPlots.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperLeftGrid.addWidget(self.Instruct4_ViewFitPlots, row, 0, 1, 2)

        # ROW 10: Instruction
        row += 1
        self.Instruct5_LockFits = QLabel()
        self.Instruct5_LockFits.setObjectName("Instruct5_LockFits")
        self.Instruct5_LockFits.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperLeftGrid.addWidget(self.Instruct5_LockFits, row, 0, 1, 2)

        row += 1
        self.pickleBtn = QPushButton()
        self.pickleBtn.setObjectName("pickleBtn")
        upperLeftGrid.addWidget(self.pickleBtn, row, 0, 1, 2)

        """ END SET UP UPPER LEFT FILTER / FIT OPTIONS """

        upperleft = QWidget()
        upperleft.setMaximumSize(225, 525)
        upperleft.setMinimumSize(225, 525)
        upperleft.setContentsMargins(5, 5, 5, 5)
        upperleft.setSizePolicy(QSizePolicy.Policy.Maximum, QSizePolicy.Policy.Maximum)
        upperleft.setLayout(upperLeftGrid)
        mainGrid.addWidget(upperleft, 0, 0, 1, 1)


        self.fig = Figure(figsize=(5,4))
        self.canvas = FigureCanvas(self.fig)
        self.fig.set_canvas(self.canvas)
        mainGrid.addWidget(self.canvas, 0, 1, 1, 1)

        upperRight = QWidget()
        upperRight.setFixedSize(225, 525)
        upperRight.setContentsMargins(0, 0, 0, 0)
        upperRightGrid = QGridLayout()
        upperRightGrid.setContentsMargins(0, 0, 0, 0)
        upperRight.setLayout(upperRightGrid)
        mainGrid.addWidget(upperRight, 0, 2, 1, 1)

        # Right row 0: Instruction
        row = 0
        plotLabel = QLabel()
        plotLabel.setObjectName("Plot Design")
        plotLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        plotLabel.setText("4. Plot Design")
        plotLabel.setStyleSheet('font-weight: bold')
        upperRightGrid.addWidget(plotLabel, row, 0, 1, 3)

        # Right Row 1:  Plot Selector
        row += 1
        self.plotComboLabel = QLabel()
        self.plotComboLabel.setText('Plot:')
        self.plotComboLabel.setContentsMargins(0, 0, 0, 0)
        upperRightGrid.addWidget(self.plotComboLabel, 1, 0, 1, 1)
        self.plotComboBox = QComboBox()
        self.plotComboBox.setContentsMargins(0, 0, 0, 0)
        self.plotComboBox.setObjectName("plotComboBox")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.addItem("")
        self.plotComboBox.setCurrentIndex(2)
        upperRightGrid.addWidget(self.plotComboBox, row, 1, 1, 2)

        # Right Row 2: Plot Isotope Selector
        row += 1
        self.isotopeComboLabel = QLabel()
        self.isotopeComboLabel.setText('Isotope:')
        self.isotopeComboLabel.setContentsMargins(0, 0, 0, 0)
        upperRightGrid.addWidget(self.isotopeComboLabel, row, 0, 1, 1)
        self.isotopeComboBox = QComboBox()
        self.isotopeComboBox.setObjectName("isotopeComboBox")
        self.isotopeComboBox.addItems(self.session.isotopes)
        self.isotopeComboBox.setCurrentIndex(len(self.session.isotopes)-1)
        self.isotopeComboBox.setContentsMargins(0, 0, 0, 0)
        upperRightGrid.addWidget(self.isotopeComboBox, row, 1, 1, 2)

        row += 1
        label = QLabel()
        label.setText("Show τ:")
        upperRightGrid.addWidget(label, row, 0, 1, 1)
        self.tauSource = QComboBox()
        self.tauSource.addItems(["Machine", "Model"])
        upperRightGrid.addWidget(self.tauSource, row, 1, 1, 2)
        self.tauSource.currentIndexChanged.connect(self.toggleTaus)



        row += 1
        label = QLabel()
        label.setText("Show ACF:")
        upperRightGrid.addWidget(label, row, 0, 1, 1)
        self.showMachineACF = QCheckBox()
        self.showMachineACF.setText("Machine")
        upperRightGrid.addWidget(self.showMachineACF, row, 1, 1, 1)
        self.showModelACF = QCheckBox()
        self.showModelACF.setText("Model")
        upperRightGrid.addWidget(self.showModelACF, row, 2, 1, 1)

        row += 1
        self.plotResiduals = QCheckBox()
        self.plotResiduals.setText("Plot residuals")
        upperRightGrid.addWidget(self.plotResiduals, row, 0, 1, 3)


        row += 1
        self.showTitle = QCheckBox()
        self.showTitle.setText("Show title")
        upperRightGrid.addWidget(self.showTitle, row, 0, 1, 3)
        self.showTitle.toggled.connect(lambda: self.drawPlotBtn.setEnabled(True))

        row += 1
        self.customScale = QCheckBox()
        self.customScale.setText("Use custom scale")
        upperRightGrid.addWidget(self.customScale, row, 0, 1, 3)

        row += 1
        self.tauLabel = QLabel()
        self.tauLabel.setText("Machine τ")
        units = QLabel()
        units.setText("nsec")
        self.deadtimeSpinBox = QDoubleSpinBox()
        self.deadtimeSpinBox.setRange(-100, 500)
        self.deadtimeSpinBox.setValue(self.session.machineDeadTime*1E+9)
        upperRightGrid.addWidget(self.tauLabel, row, 0)
        upperRightGrid.addWidget(self.deadtimeSpinBox, row, 1)
        upperRightGrid.addWidget(units, row, 2)


        row += 1
        limsGrid = QGridLayout()
        upperRightGrid.addLayout(limsGrid, row, 0, 1, 3)
        # Right Row 3:  Limit Labels
        axisLabel = QLabel()
        axisLabel.setText("Axis")
        limsGrid.addWidget(axisLabel, 0, 0, 1, 1)
        minLimLabel = QLabel()
        minLimLabel.setText("Min")
        limsGrid.addWidget(minLimLabel, 0, 1, 1, 1)
        maxLimLabel = QLabel()
        maxLimLabel.setText("Max")
        limsGrid.addWidget(maxLimLabel, 0, 2, 1, 1)
        maxLimLabel = QLabel()
        maxLimLabel.setText("Label")
        limsGrid.addWidget(maxLimLabel, 0, 3, 1, 1)


        # Right Row 4: X range
        self.xLimsLabel = QLabel()
        self.xLimsLabel.setText("X")
        limsGrid.addWidget(self.xLimsLabel, 1, 0, 1, 1)
        self.xRangeMinDSP = QDoubleSpinBox()
        self.xRangeMinDSP.setRange(-1000, 999)
        limsGrid.addWidget(self.xRangeMinDSP, 1, 1, 1, 1)
        self.xRangeMaxDSP = QDoubleSpinBox()
        self.xRangeMaxDSP.setRange(-999, 1000)
        limsGrid.addWidget(self.xRangeMaxDSP, 1, 2, 1, 1)
        self.xLabelCheck = QCheckBox()
        self.xLabelCheck.setChecked(True)
        self.xLabelCheck.setContentsMargins(0, 0, 0, 0)
        limsGrid.addWidget(self.xLabelCheck, 1, 3, 1, 1)


        # Right Row 5: Y Range
        self.yLimsLabel = QLabel()
        self.yLimsLabel.setText("Y")
        limsGrid.addWidget(self.yLimsLabel, 2, 0, 1, 1)
        # upperRightGrid.addWidget(yLimsLabel, 5, 0, 1, 1)
        self.yRangeMinDSP = QDoubleSpinBox()
        self.yRangeMinDSP.setRange(-1000, 999)
        limsGrid.addWidget(self.yRangeMinDSP, 2, 1, 1, 1)
        self.yRangeMaxDSP = QDoubleSpinBox()
        self.yRangeMaxDSP.setRange(-999, 1000)
        limsGrid.addWidget(self.yRangeMaxDSP, 2, 2, 1, 1)
        self.yLabelCheck = QCheckBox()
        self.yLabelCheck.setChecked(True)
        self.yLabelCheck.setContentsMargins(0, 0, 0, 0)
        limsGrid.addWidget(self.yLabelCheck, 2, 3, 1, 1)


        # Right Row 6: Z Range
        self.zLimsLabel = QLabel()
        self.zLimsLabel.setText("Z")
        limsGrid.addWidget(self.zLimsLabel, 3, 0, 1, 1)
        self.zRangeMinDSP = QDoubleSpinBox()
        limsGrid.addWidget(self.zRangeMinDSP, 3, 1, 1, 1)
        self.zRangeMaxDSP = QDoubleSpinBox()
        limsGrid.addWidget(self.zRangeMaxDSP, 3, 2, 1, 1)
        self.zLabelCheck = QCheckBox()
        self.zLabelCheck.setChecked(True)
        self.zLabelCheck.setContentsMargins(0, 0, 0, 0)
        limsGrid.addWidget(self.zLabelCheck, 3, 3, 1, 1)

        # Right Row 7: Colormap
        row += 1
        cmapLabel = QLabel()
        cmapLabel.setText("Colormap")
        upperRightGrid.addWidget(cmapLabel, row, 0, 1, 3)

        row += 1
        hbox = QHBoxLayout()
        self.cmapComboBox = QComboBox()
        self.cmapComboBox.setFixedWidth(100)
        cmaps = ['rainbow', 'jet', 'turbo', 'plasma', 'viridis']
        self.cmapComboBox.addItems(cmaps)
        self.cmapComboBox.setContentsMargins(0,0,0,0)
        hbox.addWidget(self.cmapComboBox)
        self.normComboBox = QComboBox()
        self.normComboBox.setFixedWidth(60)
        norm = ['lin', 'log']
        self.normComboBox.addItems(norm)
        self.normComboBox.setContentsMargins(0,0,0,0)
        hbox.addWidget(self.normComboBox)
        self.showColorbar = QCheckBox()
        self.showColorbar.setText("Show")
        self.showColorbar.setContentsMargins(0, 0, 0, 0)
        hbox.addWidget(self.showColorbar)
        upperRightGrid.addLayout(hbox, row, 0, 1, 3)


        # Right Row 8: Azimuth
        row += 1
        azLabel = QLabel()
        azLabel.setText("Azimuth")
        azLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperRightGrid.addWidget(azLabel, row, 0)

        elLabel = QLabel()
        elLabel.setText("Elevation")
        elLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperRightGrid.addWidget(elLabel, row, 1)

        rollLabel = QLabel()
        rollLabel.setText("Roll")
        rollLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        upperRightGrid.addWidget(rollLabel, row, 2)

        row += 1
        self.az = QSpinBox()
        self.az.setRange(-180, 180)
        self.az.setValue(45)
        upperRightGrid.addWidget(self.az, row, 0)


        self.el = QSpinBox()
        self.el.setValue(30)
        self.el.setRange(-180, 180)
        upperRightGrid.addWidget(self.el, row, 1)


        self.roll = QSpinBox()
        self.roll.setValue(0)
        self.roll.setRange(-180, 180)
        upperRightGrid.addWidget(self.roll, row, 2)


        # Right Row 9: Elevation

        # Right Row 10: Draw and Save Figure Buttons
        row += 1
        self.drawPlotBtn = QPushButton()
        self.drawPlotBtn.setText("Draw Plot")
        self.drawPlotBtn.clicked.connect(self.plotFits)

        # Right Row 11: Save Figure
        self.savePlotBtn = QPushButton()
        self.savePlotBtn.setText("Save Plot")
        self.savePlotBtn.setObjectName("savePlotBtn")


        hbox = QHBoxLayout()
        hbox.addWidget(self.drawPlotBtn)
        hbox.addWidget(self.savePlotBtn)
        upperRightGrid.addLayout(hbox, row, 0, 1, 3)


        """ BEGIN SET UP BOTTOM FIT RESULTS """
        #isotopes = []
        self.table = isotopeFitTable.IsotopeFitTableWidget(self.session)
        self.table.setGeometry(QRect(0, 0, 1180, 240))
        self.table.setObjectName("table")
        self.table.initFitDictionary()
        self.table.setMaximumSize(1180, 240)
        self.table.setMinimumSize(1190, 240)
        self.table.setSizePolicy(QSizePolicy.Policy.Maximum, QSizePolicy.Policy.Maximum)
        self.table.setContentsMargins(10, 0, 10, 10)
        self.table.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.table.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)

        mainGrid.addWidget(self.table, 1, 0, 1, 3)
        """ BEGIN SET UP BOTTOM FIT RESULTS """
        self.uiEnabledState('initial')
        if self.session.status['imported']:
            self.uiEnabledState('filter pending')
        if self.session.status['filtered']:
            self.uiEnabledState('fit pending')
        self.retranslateUi()
        # QtCore.QMetaObject.connectSlotsByName(self.mainWidget)
        self.setLayout(mainGrid)
        self.cloakControls()

        """ Connect Events """
        self.filterRawBtn.setFilter.connect(self.filterRawData)
        self.filterRawBtn.releaseFilter.connect(self.releaseDataFilter)
        self.isotopeFitComboBox.currentIndexChanged.connect(self.fitChanged)
        self.startFitBtn.setFit.connect(self.fitFilteredData)
        self.startFitBtn.releaseFit.connect(self.releaseDataFit)
        # self.isotopeComboBox.currentIndexChanged.connect(self.plotFits)
        # self.plotComboBox.currentIndexChanged.connect(self.plotFits)
        self.savePlotBtn.released.connect(self.savePlot)
        self.pickleBtn.clicked.connect(self.pickleData)
        self.plotComboBox.currentIndexChanged.connect(self.cloakControls)
        self.isotopeComboBox.currentIndexChanged.connect(self.getModelTau)
        self.plotResiduals.toggled.connect(self.residualsToggled)

        self.showMachineACF.toggled.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.showModelACF.toggled.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.customScale.toggled.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.deadtimeSpinBox.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.xRangeMinDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.xRangeMaxDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.yRangeMinDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.yRangeMaxDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.zRangeMinDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.zRangeMaxDSP.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.cmapComboBox.currentIndexChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.normComboBox.currentIndexChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.showColorbar.toggled.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.el.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.az.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))
        self.roll.valueChanged.connect(lambda: self.drawPlotBtn.setEnabled(True))



    def retranslateUi(self):
        _translate = QCoreApplication.translate
        self.Instruct1_AssignPars.setText(_translate("Layout", "1. Assign Filter Parameters"))
        self.Instruct1_AssignPars.setStyleSheet('font-weight: bold')
        self.outlierComboBox.setItemText(0, _translate("Layout", "None"))
        self.outlierComboBox.setItemText(1, _translate("Layout", "Tukey: 3xIQR"))
        self.outlierComboBox.setItemText(2, _translate("Layout", "Tukey: 4xIQR"))
        self.minALabel.setText(_translate("Layout", "Min Analog"))
        self.maxPLabel.setText(_translate("Layout", "Max. Pulse"))
        self.outlierLabel.setText(_translate("Layout", "Outliers"))
        self.minPLabel.setText(_translate("Layout", "Min. Pulse"))
        self.Instruct2_Extract.setText(_translate("Layout", "2. Extract Raw Data"))
        self.Instruct2_Extract.setStyleSheet('font-weight: bold')
        self.Instruct3_FitFiltered.setText(_translate("Layout", "3. Fit Filtered Raw Data"))
        self.Instruct3_FitFiltered.setStyleSheet('font-weight: bold')
        self.isotopeFitComboBox.setItemText(0, _translate("Layout", "Ordinary"))
        self.isotopeFitComboBox.setItemText(1, _translate("Layout", "Weighted"))
        self.isotopeFitComboBox.setItemText(2, _translate("Layout", "Robust"))


        self.normRLSComboBox.setItemText(0, _translate("Layout", "Whitened"))
        self.normRLSComboBox.setItemText(1, _translate("Layout", "Huber T"))
        self.normRLSComboBox.setItemText(2, _translate("Layout", "Hampel"))
        self.normRLSComboBox.setItemText(3, _translate("Layout", "Least Squares"))
        self.normRLSComboBox.setItemText(4, _translate("Layout", "AndrewWave"))
        self.normRLSComboBox.setItemText(5, _translate("Layout", "Ramsay E"))
        self.normRLSComboBox.setItemText(6, _translate("Layout", "Robust Norm"))
        self.normRLSComboBox.setItemText(7, _translate("Layout", "Trimmed Mean"))
        self.normRLSComboBox.setItemText(8, _translate("Layout", "Tukey Biweight"))

        self.Instruct4_ViewFitPlots.setText(_translate("Layout", "4. View Isotope Fits"))
        self.Instruct4_ViewFitPlots.setStyleSheet('font-weight: bold')

        self.plotComboBox.setItemText(0, _translate("Layout", "3D: ACF v. P v. t"))
        self.plotComboBox.setItemText(1, _translate("Layout", "3D: 1/P v. t/A v. 1/A"))
        self.plotComboBox.setItemText(2, _translate("Layout", "2D: ACF v. t"))
        self.plotComboBox.setItemText(3, _translate("Layout", "2D: ACF v. P"))
        self.plotComboBox.setItemText(4, _translate("Layout", "2D: P v. A"))
        self.plotComboBox.setItemText(5, _translate("Layout", "2D: 1/P v. 1/A"))
        self.plotComboBox.setItemText(6, _translate("Layout", "Stacked Residuals"))
        self.plotComboBox.setItemText(7, _translate("Layout", "ACF Residuals"))
        self.savePlotBtn.setText(_translate("Layout", "Save Plot"))
        self.Instruct5_LockFits.setText(_translate("Layout", "5. Lock Isotope Fits"))
        self.Instruct5_LockFits.setStyleSheet('font-weight: bold')
        self.pickleBtn.setText(_translate("Layout", "Save Binary Data"))

    def uiEnabledState(self, state: str):
        '''
        This code handles the enabled state of controls based on which step of the filter & fit process
        the user is in.
        :param state: str
        :return: None
        '''

        if state == 'initial':
            enabled = {'maxP': False, 'minP': False, 'minA': False, 'out': False,
                       'filtBtn': False, 'filtBtnText': 'Filter Data',
                       'fitType': False, 'fitBtn': False, 'fitBtnText': 'Fit Data',
                       'isoCombo': False, 'plotCombo': False, 'saveBtn': False, 'lockBtn': False,
                       'lBtnTxt': 'Lock Isotope Fits'}

        if state == 'filter pending':
            enabled = {'maxP': True, 'minP': True, 'minA': True, 'out': True,
                       'filtBtn': True, 'filtBtnText': 'Filter Data',
                       'fitType': False, 'fitBtn': False, 'fitBtnText': 'Fit Data',
                       'isoCombo': True, 'plotCombo': True, 'saveBtn': False, 'lockBtn': False,
                       'lBtnTxt': 'Lock Isotope Fits'}

        elif state == 'fit pending':
            enabled = {'maxP': False, 'minP': False, 'minA': False, 'out': False,
                       'filtBtn': True, 'filtBtnText': 'Refilter Data',
                       'fitType': True, 'fitBtn': True, 'fitBtnText': 'Refit Data',
                       'isoCombo': True, 'plotCombo': True, 'saveBtn': False, 'lockBtn': False,
                       'lBtnTxt': 'Lock Isotope Fits'}

        elif state == 'lock pending':
            enabled = {'maxP': False, 'minP':False, 'minA': False, 'out': False,
                       'filtBtn': False, 'filtBtnText': 'Refilter Data',
                       'fitType': True, 'fitBtn': False,'fitBtnText': 'Refit Data',
                       'isoCombo': True, 'plotCombo': True, 'saveBtn': True, 'lockBtn': True,
                       'lBtnTxt': 'Lock Isotope Fits'}

        elif state == 'locked':
            enabled = {'maxP': False, 'minP':False, 'minA': False, 'out': False,
                       'filtBtn': False, 'filtBtnText': 'Refilter Data',
                       'fitType': False, 'fitBtn': False, 'fitBtnText': 'Refit Data',
                       'isoCombo': True, 'plotCombo': True, 'saveBtn':True, 'lockBtn': True,
                       'lBtnTxt': 'Unlock Isotope Fits'}

        self.uiState = state

        self.maxPSpinBox.setEnabled(enabled['maxP'])
        self.minASpinBox.setEnabled(enabled['minP'])
        self.minPSpinBox.setEnabled(enabled['minA'])
        self.outlierComboBox.setEnabled(enabled['out'])
        self.filterRawBtn.setState(state)
        self.isotopeFitComboBox.setEnabled(enabled['fitType'])
        self.startFitBtn.setState(state)
        self.isotopeComboBox.setEnabled(enabled['isoCombo'])
        self.plotComboBox.setEnabled(enabled['plotCombo'])
        self.savePlotBtn.setEnabled(enabled['saveBtn'])
        # self.lockFitBtn.setEnabled(enabled['lockBtn'])
        # self.lockFitBtn.setText(enabled['lBtnTxt'])

    def dataImported(self):
        self.uiEnabledState('filter pending')

    def filterRawData(self):
        #Todo: Implement Filter Code here
        # Todo: TRAVERSE TO FIND FIRST SAMPLE
        # Todo: Calculate absTime seconds plus time stamp
        # Todo: Append to master filtered data set arrays
        # Todo: Subtract first sample time.
        self.session.isotopeFit["pMin"] = self.minPSpinBox.value()
        self.session.isotopeFit["pMax"] = self.maxPSpinBox.value()
        self.session.isotopeFit["aMin"] = self.minASpinBox.value()
        outlier = self.outlierComboBox.currentIndex()
        if outlier > 0:
            outlier = outlier + 2  # Scales to Tukey 3xIQR or 4xIQR
        else:
            outlier = 10
        self.session.isotopeFit["outlier"] = outlier
        self.session.filterRawData()
        self.updateFitDict()
        self.session.status["filtered"] = True
        self.uiEnabledState('fit pending')
        self.table.populateFilterTable(self.session)

    def releaseDataFilter(self):
        self.session.status["filtered"] = False
        self.uiEnabledState('filter pending')
        self.table.unpopulateFilterTable()

    def fitFilteredData(self):
        self.session.isotopeFit["algorithm"] = self.isotopeFitComboBox.currentText()
        if self.isotopeFitComboBox.currentText() == 'Robust':
            self.session.isotopeFit['norm'] = self.normRLSComboBox.currentText()
        else:
            self.session.isotopeFit['norm'] = None
        self.session.regressRawData()
        self.table.populateFitTable(self.session)
        self.uiEnabledState('lock pending')
        self.regressionComplete.emit()

    def releaseDataFit(self):
        self.table.unpopulateFitTable()
        self.uiEnabledState('fit pending')
        self.session.releaseRawDataRegression()

    def fitChanged(self):
        self.normComboLabel.setEnabled(self.isotopeFitComboBox.currentIndex() == 2)
        self.normRLSComboBox.setEnabled(self.isotopeFitComboBox.currentIndex() == 2)

    def updateFitDict(self):
        self.uiEnabledState('locked')
        pass
    
    def plotFits(self):
        self.fig.clear()
        self._ax = None

        # Get Control values
        plotIsotope = self.isotopeComboBox.currentText()
        plotType = self.plotComboBox.currentIndex()
        cmap = self.cmapComboBox.currentText()

        data = self.session.masses[plotIsotope]
        time = data.filteredTime
        idx = time.argsort()
        time = time[idx]
        time = time - np.min(self.session.scanTime)
        p = data.filteredPulse[idx]
        a = data.filteredAnalog[idx]
        calcACF = p/a
        sizes = p / np.max(p)
        sizes = p/5E+6
        machineTau = self.session.machineDeadTime

        # Read and sort scantime and machine ACF for interpolation
        scanTime = self.session.scanTime - np.min(self.session.scanTime)
        idx = scanTime.argsort()
        scanTime = scanTime[idx]
        machineACF = data.ACF[idx]
        interpACF = np.interp(time, scanTime, machineACF)

        pobs = p / (1 + p * machineTau)
        pdt = None
        dtACF = None

        a1 = self.session.masses[plotIsotope].fits["self"]["a1"]
        a2 = self.session.masses[plotIsotope].fits["self"]["a2"]
        bestfity = [1 / (a1 + a2 * t) for t in time]
        W = pobs**3 * self.session.masses[plotIsotope].totalDwell

        modelResidual = Residue(100 * (calcACF / bestfity - 1), W)
        machineResidual = Residue(100 * (calcACF / interpACF - 1), W)
        acfResidual = Residue(100 * (interpACF/bestfity - 1), W)

        if self.deadtimeSpinBox.value() != 0:
            dt = self.deadtimeSpinBox.value() * 1E-9
            pdt = pobs / (1-pobs*dt)
            dtACF = pdt/a
            dtModelResidual = Residue(100 * (dtACF / bestfity - 1), W)
        else:
            dtModelResidual = Residue()
        if self.normComboBox.currentIndex() == 0:
            norm = 'linear'
        else:
            norm = 'log'

        # 3D ACF vs. Time vs. Pulse
        if plotType == 0:
            self._ax = self.canvas.figure.add_subplot(projection='3d')
            if self.plotResiduals.isChecked():
                scat3D = self._ax.scatter(p/1E+6, time/1000, dtModelResidual.values, c=p/1E+6, cmap=cmap, norm=norm, s=sizes)
            else:
                if self.tauSource.currentText() == "Model":
                    scat3d = self._ax.scatter(pdt / 1E+6, time / 1000, dtACF, c=p / 1E+6, cmap=cmap, norm=norm, s=sizes)
                else:
                    scat3d = self._ax.scatter(p / 1E+6, time / 1000, p / a, c=p / 1E+6, cmap=cmap, norm=norm, s=sizes)
            self.getLimits()
            # self._ax.set_title(plotIsotope)
            # self._ax.set_title("²³⁸U")
            # self._ax.set_title("²⁰⁶Pb")
            if self.xLabelCheck.isChecked():
                self._ax.set_xlabel("Pulse rate (x10⁶ cps)")
            if self.yLabelCheck.isChecked():
                self._ax.set_ylabel("Time (x10³ sec)")
            if self.zLabelCheck.isChecked():
                self._ax.set_zlabel("ACF (cps)")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat3d, ax=self._ax, shrink= 0.40, pad=.15, aspect=30)
                cbar.ax.set_ylabel("Pulse rate (x10$^{{{6}}}$ cps)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15
            self.savePlotBtn.setEnabled(True)

        # 3D: 1/P vs. t/A vs. 1/A  Model fitting space
        elif plotType == 1:
            self._ax = self.canvas.figure.add_subplot(projection='3d')
            if norm == 'linear':
                normalize = matplotlib.colors.Normalize(vmin=self.minPSpinBox.value(), vmax=self.maxPSpinBox.value())
            else:
                normalize = matplotlib.colors.LogNorm(vmin=self.minPSpinBox.value(), vmax=self.maxPSpinBox.value())
            scat3d = self._ax.scatter(1E+6 / p, time/ a, 1000 / a, c=p/1E+6, cmap=cmap, norm= norm, alpha=sizes, s=sizes)
            self.getLimits()
            if self.xLabelCheck.isChecked():
                self._ax.set_xlabel("1/pulse rate (μsec)")
            if self.yLabelCheck.isChecked():
                self._ax.set_ylabel("Time/analog bits (sec)")
            if self.zLabelCheck.isChecked():
                self._ax.set_zlabel("1000/analog bits")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat3d, ax=self._ax, shrink= 0.40, pad=.15, aspect=30)
                cbar.ax.set_ylabel("Pulse rate (x10$^{{{6}}}$ cps)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15
            self.savePlotBtn.setEnabled(True)

        # 2D: ACF vs time
        # Todo: Sort residual plotting
        # Todo: Sort Machine ACF
        elif plotType == 2:
            self._ax = self.canvas.figure.add_subplot()
            maACF = self.showMachineACF.isChecked()
            moACF = self.showModelACF.isChecked()
            residuals = self.plotResiduals.isChecked()

            if residuals:
                if self.tauSource.currentIndex() == 1:
                    scat = self._ax.scatter(time/1000, dtModelResidual.values, c=pobs, cmap=cmap, norm=norm, s=sizes)
                    self._ax.axhline(dtModelResidual.mean, color='blue', linewidth=1)
                    self._ax.axhline(dtModelResidual.mean + dtModelResidual.stdev, color='blue', linestyle='dashed',
                                     linewidth=1)
                    self._ax.axhline(dtModelResidual.mean - dtModelResidual.stdev, color='blue', linestyle='dashed',
                                     linewidth=1)
                else:
                    scat = self._ax.scatter(time/1000, modelResidual.values, c=pobs, cmap=cmap, norm=norm, s=sizes)
                    self._ax.axhline(modelResidual.mean, color='blue', linewidth=1)
                    self._ax.axhline(modelResidual.mean + modelResidual.stdev, color='blue', linestyle='dashed',
                                     linewidth=1)
                    self._ax.axhline(modelResidual.mean - modelResidual.stdev, color='blue', linestyle='dashed',
                                     linewidth=1)

                if moACF:
                    self._ax.scatter(time/1000, acfResidual.values, c='black', s=0.01)
                    self._ax.axhline(acfResidual.mean, color='black', linestyle='--', linewidth=1)


                if maACF:
                    self._ax.scatter(time/1000, 100*(calcACF/interpACF-1), c='black', s=0.01)

            else:
                if self.tauSource.currentIndex() == 1:
                    scat = self._ax.scatter(time/1000, dtACF, c=pobs, cmap=cmap, norm=norm, s=sizes)
                else:
                    scat = self._ax.scatter(time/1000, calcACF, c=pobs, cmap=cmap, norm=norm, s=sizes)
                if maACF:
                    self._ax.scatter(scanTime/1000, machineACF, c='black', s=0.01)
                if moACF:
                    ts = [min(time), max(time)]
                    ys = [1/(a1 + a2*t) for t in ts]
                    self._ax.plot([t/1000 for t in ts], ys, c='blue')


            self.getLimits()
            if self.xLabelCheck.isChecked():
                if self.plotResiduals.isChecked():
                    self._ax.set_ylabel("ACF Residuals (%)")
                else:
                    self._ax.set_ylabel("ACF (cps)")
            if self.yLabelCheck.isChecked():
                self._ax.set_xlabel("Time (x10$^{{{3}}}$ sec)")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat, ax=self._ax, shrink= 0.40, pad=.05, aspect=30)
                cbar.ax.set_ylabel("Pulse rate (x10$^{{{6}}}$ cps)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15

            self.savePlotBtn.setEnabled(True)

            interval = 2000
            first = np.mean(calcACF[:interval])
            dfirst = np.std(calcACF[:interval])
            last = np.mean(calcACF[-interval:])
            dlast = np.std(calcACF[-interval:])
            # print (f'First: {first} +/- {dfirst}; Last: {last} +/- {dlast}')

        # 2D: ACF vs Pulse Rate
        elif plotType == 3:
            self._ax = self.canvas.figure.add_subplot()
            if self.tauSource.currentText() == "Model":
                dt = self.getModelTau()
                if dt is not None:
                    pobs = p/(1+p*machineTau)
                    pcorr = pobs/(1-pobs*dt*1E-9)
                    if self.plotResiduals.isChecked():
                        scat = self._ax.scatter(pcorr/1E+6, dtModelResidual.values, c=time/1000, cmap=cmap,
                                                norm=norm, s=sizes)
                    else:
                        scat = self._ax.scatter(pcorr/1E+6, pcorr/a, c=time / 1000, cmap=cmap, norm=norm, s=sizes)
            else:
                if self.plotResiduals.isChecked():
                    scat = self._ax.scatter(p / 1E+6, acfResidual.values, c=time / 1000, cmap=cmap,
                                            norm=norm, s=sizes)
                else:
                    scat = self._ax.scatter(p/1E+6, p/a, c=time/1000, cmap=cmap, norm=norm, s=sizes)
            self.getLimits()
            if self.xLabelCheck.isChecked():
                self._ax.set_xlabel("Pulse rate (x10⁶ cps)")
            if self.yLabelCheck.isChecked():
                self._ax.set_ylabel("ACF (cps)")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat, ax=self._ax, shrink= 0.75, pad=.05, aspect=20)
                cbar.ax.set_ylabel("Time (x10$^{{{3}}}$ sec)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15
            self.savePlotBtn.setEnabled(True)

        # 2D: P vs. A
        elif plotType == 4:
            self._ax = self.canvas.figure.add_subplot()
            if self.tauSource.currentText() == "Model":
                dt = self.getModelTau()
                if dt is not None:
                    pobs = p/(1+p*machineTau)
                    pcorr = pobs/(1-pobs*dt*1E-9)
                    scat = self._ax.scatter(a/1E+3, pcorr/1E+6, c=time, cmap=cmap, norm=norm, s=sizes)
            else:
                scat = self._ax.scatter(a/1E+3, p/1E+6, c=time/1000, cmap=cmap, norm=norm, s=sizes)
            self.getLimits()
            if self.xLabelCheck.isChecked():
                self._ax.set_xlabel("Analog bits (x10³)")
            if self.yLabelCheck.isChecked():
                self._ax.set_ylabel("Pulse rate (x10⁶ cps)")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat, ax=self._ax, shrink= 0.75, pad=.05, aspect=20)
                cbar.ax.set_ylabel("Time (x10$^{{{3}}}$ sec)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15
            self.savePlotBtn.setEnabled(True)

        # 2D:  1/P vs. 1/A Modeling Framework
        elif plotType == 5:
            self._ax = self.canvas.figure.add_subplot()
            scat = self._ax.scatter(100000/a, 1E+6/p, c=time/1000, cmap=cmap, norm='linear', s=sizes)
            self.getLimits()
            if self.yLabelCheck.isChecked():
                self._ax.set_ylabel("1/pulse rate (x10$^{{{-6}}}$ sec)")
            if self.xLabelCheck.isChecked():
                self._ax.set_xlabel(f"1/analog bits (x10$^{{{-5}}}$)")
            if self.showColorbar.isChecked():
                cbar = self.fig.colorbar(scat, ax=self._ax, shrink= 0.75, pad=.05, aspect=20)
                cbar.ax.set_ylabel("Time (x10$^{{{3}}}$ sec)", rotation=270)
                cbar.ax.get_yaxis().labelpad = 15
            self.savePlotBtn.setEnabled(True)
            tau2d = data.fits["2D"]["tau"]
            alpha2d = data.fits["2D"]["a1"]
            if tau2d is not None:
                xs = [0, self._ax.get_xlim()[1]/100000]
                ys = [tau2d + alpha2d * x for x in xs]
                xs = [100000 * x for x in xs]
                ys = [1E+6*y for y in ys]
                self._ax.plot(xs, ys, color='black', linewidth=0.5)


            y = self._ax.get_ylim()
            yrange = np.abs(y[1] - y[0])
            yoff = y[1] - 0.25*yrange
            x = self._ax.get_xlim()
            xrange = np.abs(x[1] - x[0])
            xoff = x[0] + 0.05*xrange
            dtau = data.fits["2D"]["dtau"]
            da1 = data.fits["2D"]["da1"]
            rdtau = 100*dtau/tau2d
            rda1 = 100*da1/alpha2d
            acf = 1/alpha2d
            #TODO other cases
            anno = (f'Machine $\\tau$ = {machineTau*1E+9:0.2f} nsec \n\n'
                    f'Fit $\\tau$ = {tau2d*1E+9:0.2f} nsec (± {rdtau:0.2f}%) \n'
                    f'1/$\\alpha$ = {alpha2d:0.4f} sec (±{rda1:0.2f}%) \n'
                    f'$\\alpha$ = {acf:0.2f} sec⁻¹')
            self._ax.annotate(anno,[xoff, yoff])

        # 1D Stacked Histograms of ACF biases
        elif plotType == 6:
            bins = 500
            yoffsetFrac = 0.7
            gt = [0, 1E+6, 2E+6, 3E+6, 4E+6, 4.5E+6]
            lt = [1.000001E+6, 2.000001E+6, 3.000001E+6, 4.000001E+6, 4.500001E+6, 5.000001E+6]
            cmap = matplotlib.colormaps[self.cmapComboBox.currentText()]
            rgbas = [cmap(l / 5E+6) for l in lt]
            handles = [Rectangle((0, 0), 0.5, 0.5, color=c, ec="k") for c in rgbas]
            ax0 = self.canvas.figure.add_subplot(3, 1, 1)
            ax1 = self.canvas.figure.add_subplot(3, 1, 2)
            ax2 = self.canvas.figure.add_subplot(3, 1, 3)

            mR = []
            maR = []
            dmR = []
            labels = []
            rgbas = []

            stdev = machineResidual.stdev
            temp = re.compile("([a-zA-Z]+)([0-9]+)")
            result = temp.match(plotIsotope).groups()
            isoString = r'$^{%s}%s$' % (result[1], result[0])
            for g, l in zip(gt, lt):
                mask =  np.ma.masked_inside(pobs, l, g).mask
                n = len(modelResidual.values[mask])
                labels.append(f'{g/1E+6:0.1f}-{l/1E+6:0.1f}  N = {n}')
                if n > 0:
                    mR.append(modelResidual.values[mask])
                    maR.append(machineResidual.values[mask])
                    rgbas.append(cmap(l / 5E+6))
                    if dtModelResidual.values is not None:
                        dmR.append(dtModelResidual.values[mask])


            axes = [ax0, ax1, ax2]
            titles = [f"{isoString} linear ACF residuals with machine $\\tau$",
                      f"{isoString} machine ACF residuals with machine $\\tau$",
                      f"{isoString} linear ACF residuals with model $\\tau$"]
            histData = [mR, maR, dmR]
            taus = [machineTau*1E+9, machineTau*1E+9, self.deadtimeSpinBox.value()]
            flatData = [modelResidual, machineResidual, dtModelResidual]


            i = 0
            for axis, title, hd, tau, fd in zip(axes, titles, histData, taus, flatData):
                axis.set_title(title, fontsize=10)
                if self.customScale.isChecked():
                    axis.set_xlim((self.xRangeMinDSP.value(), self.xRangeMaxDSP.value()))
                else:
                    axis.set_xlim((-2.5*stdev, 2.5*stdev))
                axis.axvline(0, color='black', linestyle='--', lw=0.4)

                if fd.values is not None:
                    axis.hist(hd, bins, histtype='bar', stacked=True, color=rgbas)
                    axis.axvline(fd.mean)
                    if i <= 1:
                        annoText = (f'Bias: {fd.mean:0.2f} ± {fd.stdev: 0.2f} (%)\n'
                                    f'$\\tau$: {tau:0.2f} nsec')

                    if i > 1:
                        if fd.wMean is not None:
                            annoText = (f'Bias: {fd.mean:0.2f} ± {fd.stdev: 0.2f} (%)\n'
                                        f'Weighted Bias: {fd.wMean:0.2f} ± {fd.wStdev: 0.2f} (%)\n'
                                        f'$\\tau$: {tau:0.2f} nsec\n\n'
                                        f'A only: {data.anOnly}')
                            axis.axvline(fd.wMean, color='red')
                            yoffsetFrac = 0.35

                    xlim = axis.get_xlim()
                    xanno = xlim[0] + 0.01 * (xlim[1] - xlim[0])
                    ylim = axis.get_ylim()
                    yanno = ylim[0] + yoffsetFrac * (ylim[1] - ylim[0])
                    axis.annotate(annoText, (xanno, yanno), fontsize=10)
                    axis.get_xaxis().set_visible(i>=2)
                    i+=1

            handles.reverse()
            labels.reverse()
            leg = ax1.legend(handles, labels, title = 'Pulse rate (Mcps)', loc=1, prop={'size':8})
            leg.get_title().set_fontsize('8')
            self.fig.tight_layout(pad=1.0)

        # 2D Machine ACF Bias plot
        elif plotType == 7:
            self._ax = self.canvas.figure.add_subplot()
            anOnlyTime = data.anOnlyTime - np.min(self.session.scanTime)
            interpAnalogOnlyACF = np.interp(anOnlyTime, scanTime, machineACF)
            interpAnalogOnlyBestFitY = np.interp(anOnlyTime, time, bestfity)
            extrapolatedResidual = Residue(100 * (interpAnalogOnlyACF / interpAnalogOnlyBestFitY - 1))
            cmap = 'turbo'
            cc = np.abs(extrapolatedResidual.values) / 10
            # plt.hist(extrapolatedResidual.values, bins=500)
            self._ax.scatter(anOnlyTime, extrapolatedResidual.values, marker='.',
                             c='red', norm='linear', cmap=cmap, s=1)

            self._ax.axhline(extrapolatedResidual.mean)
            self._ax.axhline(extrapolatedResidual.mean + extrapolatedResidual.stdev, linestyle='--')
            self._ax.axhline(extrapolatedResidual.mean - extrapolatedResidual.stdev, linestyle='--')
            # Todo: Add annotation
            # print(f'extrapolation bias: {extrapolatedResidual.mean:0.3f}')
            # print(f'extrapolation bias: {extrapolatedResidual.stdev:0.3f}')

        self.canvas.draw()
        self.drawPlotBtn.setEnabled(False)
    
    def savePlot(self):
        if self.plotResiduals.isChecked():
            resi ="_residuals"
        else:
            resi = ''
        isoText = self.isotopeComboBox.currentText()
        plotIndex  = self.plotComboBox.currentIndex()
        plotTexts = ["3D", "3D_reciprocal", "alpha_time", "alpha_pulse",
                     "pulse_analog", "2D_reciprocal", "stacked_residual", "alpha_residual"]
        tau = self.tauSource.currentText()
        dt = str(f"{self.deadtimeSpinBox.value():0.2f}").replace('.','_')
        plotName = f'{isoText}_{plotTexts[plotIndex]}{resi}_{tau}_{dt}'
        startingPath = os.path.join(self.session.startDir, plotName)
        fileName, _ = QFileDialog.getSaveFileName(self,
                                                  "Save Figure",
                                                  startingPath,
                                                  "PDF Files(*.pdf);; PNG Files(*.png)",
                                                  options=QFileDialog.Option.DontUseNativeDialog)
        if fileName:
            self.fig.savefig(fileName,dpi=1200)

    def pickleData(self):
        self.startDir = None
        dlg = QFileDialog()
        dlg.setFileMode(QFileDialog.FileMode.AnyFile)
        pickleFile, filter = dlg.getSaveFileName(
            None,
            "Select Data Files",
            self.session.picklePath,
            "Python Pickle File (*.p)")
        if pickleFile:
            with open(pickleFile, 'wb') as fid:
                pickle.dump(self.session, fid)
            fid.close()
            self.regressionPickled.emit(pickleFile)

    def cloakControls(self):
        plotType = self.plotComboBox.currentIndex()
        isotope = self.isotopeComboBox.currentText()
        threeDee = plotType in [0, 1]
        twoDee = plotType in [0, 1, 2, 3, 4, 5]

        self.xRangeMinDSP.setEnabled(True)
        self.xRangeMaxDSP.setEnabled(True)
        self.yRangeMinDSP.setEnabled(twoDee)
        self.yRangeMaxDSP.setEnabled(twoDee)
        self.zRangeMinDSP.setEnabled(threeDee)
        self.zRangeMaxDSP.setEnabled(threeDee)
        self.el.setEnabled(threeDee)
        self.az.setEnabled(threeDee)
        self.roll.setEnabled(threeDee)

        self.tauSource.setEnabled(plotType in [0, 2, 3, 4])
        self.plotResiduals.setEnabled(plotType in [0, 2, 3])
        self.showMachineACF.setEnabled(plotType in [2])  # Could work for others not yet developed

        # Reset to autoscale with new plot device
        self.tauSource.setCurrentIndex(0)
        self.showMachineACF.setChecked(False)
        self.showModelACF.setChecked(False)
        self.customScale.setChecked(False)

        self.drawPlotBtn.setEnabled(True)

        if plotType == 6:
            moTau = self.session.masses[isotope].fits["self"]["tau"]
            maTau = self.session.machineDeadTime
            if moTau is not None:
                self.deadtimeSpinBox.setValue(moTau*1E+9)
                self.tauLabel.setText("Model τ")
            else:
                self.deadtimeSpinBox.setValue(maTau*1E+9)
                self.tauLabel.setText("Machine τ")

        axisLabels = [["P", "t", "ACF"],
                      ["1/P", "t/A", "1/A"],
                      ["t", "ACF", ""],
                      ["P", "ACF", ""],
                      ["A", "P", ""],
                      ["1/A", "1/P" ""],
                      ["ACF", "", ""],
                      ["t", "Bias", ""]]
        al = axisLabels[plotType]
        self.xLimsLabel.setText(al[0])
        self.yLimsLabel.setText(al[1])
        self.zLimsLabel.setText(al[2])

    def toggleTaus(self):
        self.drawPlotBtn.setEnabled(True)
        isotope = self.isotopeComboBox.currentText()
        try:
            modelTau = self.session.masses[isotope].fits["self"]["tau"]
        except:
            modelTau = None
        if self.tauSource.currentText() == "Model":
            if modelTau is not None:
                self.deadtimeSpinBox.setValue(modelTau * 1E+9)
                self.tauLabel.setText("Model τ")
            else:
                self.deadtimeSpinBox.setValue(self.session.machineDeadTime * 1E+9)
                self.tauSource.setCurrentIndex(0)
                self.tauLabel.setText("Machine τ")

        elif self.tauSource.currentText() == "Machine":
            self.deadtimeSpinBox.setValue(self.session.machineDeadTime * 1E+9)
            self.tauLabel.setText("Machine τ")

    def residualsToggled(self):
        self.customScale.setChecked(False)
        self.drawPlotBtn.setEnabled(True)

    def getLimits(self):
        plotType = self.plotComboBox.currentIndex()
        if self.showTitle.isChecked():
            isotope = self.isotopeComboBox.currentText()
            element = re.search(r'[a-zA-Z]+', isotope)[0]
            num = re.search(r'[0-9]+', isotope)[0]
            title = f'$^{{{str(num)}}}${element}'
            self._ax.set_title(title)

        threeDee = plotType in [0, 1]
        twoDee = plotType in [0, 1, 2, 3, 4, 5]

        if not self.customScale.isChecked():
            self.xRangeMinDSP.setValue(self._ax.get_xlim()[0])
            self.xRangeMaxDSP.setValue(self._ax.get_xlim()[1])
            if twoDee:
                self.yRangeMinDSP.setValue(self._ax.get_ylim()[0])
                self.yRangeMaxDSP.setValue(self._ax.get_ylim()[1])
            if threeDee:
                self.zRangeMinDSP.setValue(self._ax.get_zlim()[0])
                self.zRangeMaxDSP.setValue(self._ax.get_zlim()[1])
                self.az.setValue(self._ax.azim)
                self.el.setValue(self._ax.elev)
                self.roll.setValue(self._ax.roll)
        else:
            self._ax.set_xlim((self.xRangeMinDSP.value(), self.xRangeMaxDSP.value()))
            if twoDee:
                self._ax.set_ylim((self.yRangeMinDSP.value(), self.yRangeMaxDSP.value()))
            if threeDee:
                self._ax.set_zlim((self.zRangeMinDSP.value(), self.zRangeMaxDSP.value()))
                self._ax.view_init(elev=self.el.value(), azim=self.az.value(), roll=self.roll.value())

    def getModelTau(self):
        self.drawPlotBtn.setEnabled(True)
        plotIsotope = self.isotopeComboBox.currentText()
        modelTau = self.session.masses[plotIsotope].fits['self']['tau']
        if modelTau is not None:
            modelTau = modelTau*1E+9
            self.deadtimeSpinBox.setValue(modelTau)
        return modelTau

class Residue:
    def __init__(self, values = None, weights = None):
        self.values = None
        self.mean = None
        self.wMean = None
        self.stdev = None
        self.wStdev = None
        if values is not None:
            self.values = values
            l = len(self.values)
            self.mean = np.mean(values)
            self.stdev = np.std(values)
        if weights is not None:
            self.wMean = np.sum(weights*values)/np.sum(weights)
            num = np.sum(weights*np.square(values-self.wMean))
            den = ((l-1)/l)*np.sum(weights)
            self.wStdev = num/den


class FilterButton(QPushButton):
    setFilter = pyqtSignal()
    releaseFilter = pyqtSignal()
    def __init__(self):
        super().__init__()
        self.setText("Filter Data")
        self.setEnabled(False)
        self.released.connect(self.makeFilterEvent)

    def setState(self, state):
        if state == 'filter pending':
            self.setText("Filter Data")
            self.setEnabled(True)
            self.released.disconnect()
            self.released.connect(self.makeFilterEvent)
        elif state == 'fit pending':
            self.setText("Refilter Data")
            self.setEnabled(True)
            self.released.disconnect()
            self.released.connect(self.releaseFilterEvent)
        elif state == 'lock pending':
            self.setText("Refilter Data")
            self.setEnabled(False)
        elif state == 'locked':
            self.setText("Refilter Data")
            self.setEnabled(False)

    def makeFilterEvent(self):
        self.setFilter.emit()
    def releaseFilterEvent(self):
        self.releaseFilter.emit()


class FitButton(QPushButton):
    setFit = pyqtSignal()
    releaseFit = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setText("Fit Data")
        self.setEnabled(False)
        self.released.connect(self.makeFitEvent)

    def setState(self, state):
        if state == 'filter pending':
            self.setText("Fit Data")
            self.setEnabled(False)
            self.released.disconnect()
            self.released.connect(self.makeFitEvent)
        elif state == 'fit pending':
            self.setText("Fit Data")
            self.setEnabled(True)
            self.released.disconnect()
            self.released.connect(self.makeFitEvent)
        elif state == 'lock pending':
            self.setText("Refit Data")
            self.setEnabled(True)
            self.released.disconnect()
            self.released.connect(self.releaseFitEvent)
        elif state == 'locked':
            self.setText("Refit Data")
            self.setEnabled(False)

    def makeFitEvent(self):
        self.setFit.emit()

    def releaseFitEvent(self):
        self.releaseFit.emit()


class AppDemo(QMainWindow):
    def __init__(self):
        super().__init__()
        session = Session()
        # pPath ="/Users/jeremyhourigan/PycharmProjects/ACFModeler/test/SESSION.p"
        # pPath = "/Users/jeremyhourigan/PycharmProjects/ACFModeler/test/SESSION_SEQ1.p"
        pPath = "/Users/jeremyhourigan/My Drive/LA-ICP-MS/External_User_Data/PennState/pennState30um40pct.p"
        with open(pPath, 'rb') as fid:
            session = pickle.load(fid)
        fid.close()
        # print(session.isotopes)
        self.ui = FilterFitWidget(session)
        self.ui.setupUi()
        self.setCentralWidget(self.ui)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    demo = AppDemo()
    demo.show()
    app.exit(app.exec())
